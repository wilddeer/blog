---
description: 'Пока переделывал блог, захотелось, чтобы посреди поста можно было ворваться с каким-нибудь блоком во всю ширину окна.'
image: cover.jpg?v=2
---

<%
    const title = 'Как заверстать блок во всю ширину окна внутри блока с произвольной шириной';
    const pic = 'wil-stewart-RpDA3uYkJWM-unsplash.jpg';
%>

# <%= title %> {.sr-only}

Пока переделывал блог, захотелось, чтобы посреди поста можно было ворваться с каким-нибудь блоком во всю ширину окна. Например, вот так:

<figure class="is-demo is-arbitrary" style="background: #011126 no-repeat center/cover url(<%= pic %>); padding-top: 6em; padding-bottom: 6em; text-shadow: 0 0 0.5em rgba(0, 0, 0, 0.5);">
    <div class="content-box text-container" style="color: rgba(255, 255, 255, 0.9); text-align: center;" aria-hidden="true">
        <h1 class="is-smaller"><%= title %></h1>
    </div>
    <img class="sr-only" src="<%= pic %>" alt="Просто рандомная космическая фотка с Ансплеша. Красивенькая.">
    <figcaption>
        Фотка <a class="is-colored-bg" href="https://unsplash.com/@wilstewart3?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText">Вила Стюарта</a> из <a class="is-colored-bg" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Ансплеша</a>
    </figcaption>
</figure>

Ширина основной колонки с контентом при этом абсолютно произвольная и может меняться в зависимости от размеров окна, настроения браузера и фазы луны. Единственное, что про нее достоверно известно — она выровнена по центру:

![](demo.png =800x563)
{.is-ootb}

Самый очевидный способ — прервать блок с контентом, сделать блок без маржинов, затем продолжить контент:

![](block-break.png =800x563)
{.is-ootb}

Проблема в том, что посты удобно писать маркдауном, а в маркдауне от такого способа получается адская каша, за которой сложно следить:

```markdown
<div class="text-content">

# Пост!

Бла бла бла-бла бла. Бла бла? Бла бла-бла...

...бла блабла:

</div>

<div class="fullwidth">
    <!-- какая-то демка -->
</div>

<div class="text-content">

Бла блаааа бла бла-бла...

<!-- ...one eternity later -->

</div>
```

А хочется вот так:

```markdown
# Пост!

Бла бла бла-бла бла. Бла бла? Бла бла-бла...

...бла блабла:

<div class="fullwidth">
    <!-- какая-то демка -->
</div>

Бла блаааа бла бла-бла...
```

Окей, вставляем блок в контент и даем ему `width: 100vw`:

![](step1.png =800x563)
{.is-ootb}

Теперь его надо сдвинуть к левому краю окна. Расстояние неизвестно, но у нас есть ширина блока с контентом (`100%`) и ширина окна (`100vw`). Сначала двигаем блок направо с помощью `margin-left: 50%`:

![](step2.png =800x563)
{.is-ootb}

Теперь блок начинается ровно с середины окна. Отнимаем `50vw`, чтобы блок уехал к левому краю. Получается `margin-left: calc(50% - 50vw)`, блок встает на нужное место:

![](step3.png =800x563)
{.is-ootb}

Стиль блока выглядит так:

```css
.fullwidth {
    width: 100vw;
    margin-left: calc(50% - 50vw);
}
```

Класс, то что надо.

... или нет? А это что за хрень?

![](fuuuuuuuuu.png?v=2 =533x263)

Горизонтальный скролл, блин, откуда?

Оказывается, ширина вертикального скроллбара включается в ширину вьюпорта, то есть `100vw` — это больше, чем нам нужно, и появляется горизонтальный скролл. Не представляю, зачем это сделано именно так, не могу придумать случая, когда это было бы полезным.

А счастье было так близко. Окей, время костылей. Гуглением находится один приемлемый костыль: засунуть в `<head>` скрипт, который будет класть в css-переменную `1vw` здорового человека (то есть без учета ширины скроллбара) и пересчитывать его при ресайзах:

```html
<script>
(function () {
    function setVw() {
        const vw = document.documentElement.clientWidth / 100;
        document.documentElement.style.setProperty('--vw', `${vw}px`);
    }

    setVw();
    window.addEventListener('resize', setVw);
}());
</script>
```

Теперь у нас есть переменная `var(--vw)`, в которой лежит нужное нам количество пикселей. Но по [старой традиции](https://htmlacademy.ru/blog/boost/frontend/graceful-degradation) лучше использовать ее с фоллбеком на обычный `1vw`, вот так: `var(--vw, 1vw)`{.nowrap}.

В результате стиль блока превращается в...

```css
.fullwidth {
    width: calc(100 * var(--vw, 1vw));
    margin-left: calc(50% - 50 * var(--vw, 1vw));
}
```

Мде.

Препроцессоры немного сглаживают эту жесть. Я себе сделал переменную `$vw: var(--vw, 1vw)`{.nowrap}, мой стиль теперь выглядит как-то так:

```css
.fullwidth
    width: calc(100 * $vw)
    margin-left: calc(50% - (50 * $vw))
```

Жить можно.

## P.S. Скроллбары на маке

Если вы верстаете на маке, рекомендую включить в настройках системы постоянное отображение скроллбаров: сразу будут видны косяки с горизонтальным (а иногда и с&nbsp;вертикальным) скроллом.

Подавляющее большинство ваших пользователей на винде, где скроллбары всегда видны. Будьте чуть ближе к ним.
